# orders_service/spec/models/order_spec.rb
require 'rails_helper'
require 'webmock/rspec'

RSpec.describe Order, type: :model do
  let(:customer_id) { 1 }
  let(:customer_details) { { customer_id: customer_id, customer_name: 'Test Customer', address: '123 Test St', orders_count: 5 } }

  before do
    # 1. Stub the malformed request generated by the validation matcher
    #    when it tests with customer_id being nil or empty.
    stub_request(:get, "http://127.0.0.1:3001/api/v1/customers/").
      to_return(status: 404, body: '{"error": "Invalid ID"}', headers: { 'Content-Type' => 'application/json' })

    # 2. (Keep or add) Stub for successful requests with a real ID
    stub_request(:get, /http:\/\/127.0.0.1:3001\/api\/v1\/customers\/\d+/).
      to_return(status: 200, body: '{"name": "Test Customer"}', headers: { 'Content-Type' => 'application/json' })
  end

  it { should validate_presence_of(:customer_id) }
  it { should validate_presence_of(:product_name) }
  it { should validate_presence_of(:quantity) }
  it { should validate_numericality_of(:quantity).is_greater_than(0).only_integer }
  it { should validate_presence_of(:price) }
  it { should validate_numericality_of(:price).is_greater_than_or_equal_to(0) }
  it { should validate_presence_of(:status) }

  describe '#customer_exists_in_customer_service' do
    context 'when customer exists' do
      it 'adds no error to customer_id' do
        order = build(:order, customer_id: customer_id)
        order.valid? # Call validations
        expect(order.errors[:customer_id]).to be_empty
      end
    end

    context 'when customer does not exist' do
      before do
        stub_request(:get, "http://localhost:3001/api/v1/customers/999")
          .to_return(status: 404, body: { error: "Customer not found" }.to_json, headers: { 'Content-Type' => 'application/json' })
        allow(CustomerApiClient).to receive(:fetch_customer_details).and_return(nil)
      end

      it 'adds an error to customer_id' do
        order = build(:order, customer_id: 999)
        order.valid?
        expect(order.errors[:customer_id]).to include("does not exist or CustomerService is unreachable")
      end
    end

    context 'when CustomerService is unreachable' do
      before do
        stub_request(:get, "http://localhost:3001/api/v1/customers/#{customer_id}")
          .to_raise(Faraday::ConnectionFailed.new("Connection refused"))
        allow(CustomerApiClient).to receive(:fetch_customer_details).and_raise(Faraday::ConnectionFailed.new("Connection refused"))
      end

      it 'adds an error to customer_id' do
        order = build(:order, customer_id: customer_id)
        order.valid?
        expect(order.errors[:customer_id]).to include("does not exist or CustomerService is unreachable")
      end
    end
  end

  describe 'event generation' do
    before do
      # Le dice a RSpec que cuando se llame a EventPublishers::OrderPublisher.publish_created,
      # debe simplemente aceptarlo y no ejecutar el código real del método.
      allow(EventPublishers::OrderPublisher).to receive(:publish_created)
    end
    it 'publishes an order.created event after creating an order' do
      order = create(:order, customer_id: customer_id) # Usa create para activar el callback
      expect(EventPublishers::OrderPublisher).to have_received(:publish_created).with(order)
    end
  end
end
